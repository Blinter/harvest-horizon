/**
 * @file SignUp.jsx
 * @description User registration component for Harvest Horizon. Handles input
 *   validation and registration requests via the `UserProvider` context.
 * @module SignUp
 *
 * @requires react - For component creation and state management.
 * @requires reactstrap - For UI components (Form, Button, etc.).
 * @requires prop-types - For component prop type validation.
 * @requires uuid - For generating unique keys for error messages.
 * @requires ../../library/auth.service - Assumed user context provider uses
 *   this or similar service.
 * @requires ../context/UserProvider - To access the register function.
 * @requires ../../utils/errorHandler.js - For handling registration errors.
 */

import { useState, memo, useRef } from 'react';
import {
  Row,
  Col,
  Card,
  CardBody,
  Button,
  Form,
  FormGroup,
  Label,
  Input,
} from 'reactstrap';
import PropTypes from 'prop-types';
import { useUser } from '../context/UserProvider';
import { v4 as uuidv4 } from 'uuid';
import { handleError } from '../../utils/errorHandler.js';

/**
 * Translates potential backend or network error messages into user-friendly
 * strings suitable for display in the UI.
 *
 * @param {Error|Array<string>|any} error - The error object caught during the
 *   registration process, or an array of validation messages.
 * @returns {Array<string>} An array of user-friendly error messages to be
 *   displayed to the user. Returns a generic message if the error type is
 *   unknown.
 */
const translateError = (error) => {
  let messages = [];

  if (error instanceof Error) {
    const msg = error.message;
    // Check for specific error messages from the backend/context
    if (msg.startsWith('Duplicate username:')) {
      messages.push(
        'This username is already taken. Please choose another one.'
      );
    } else if (msg.includes('Please provide a valid email address')) {
      messages.push('Please provide a valid email address.');
    } else if (msg.includes('must be at least')) {
      // Length errors
      messages.push(msg);
    } else if (msg.includes('must be no more than')) {
      // Length errors
      messages.push(msg);
    } else if (msg.includes('Missing required field')) {
      messages.push(msg);
    } else if (msg.includes('Could not connect to the server')) {
      messages.push(
        'Unable to connect to the server. Please check your connection and try again.'
      );
    } else {
      // Generic message for other Errors
      messages.push(msg || 'An unexpected error occurred. Please try again.');
    }
  } else if (Array.isArray(error)) {
    // Assume array contains validation messages from the server
    messages = error.map((msg) => msg); // Pass through array messages
  } else {
    // Fallback for unknown error types
    messages.push('An unexpected error occurred. Please try again.');
  }

  return messages.length > 0 ? messages : ['An unknown error occurred.'];
};

/**
 * Renders the user registration form.
 *
 * Captures username, email, and password, performs basic client-side
 * validation (password match), and uses the `useUser` context to submit the
 * registration request. Displays errors returned from the registration
 * process.
 *
 * @component SignUp
 * @param {object} props - Component props.
 * @param {Function} props.cancelHandler - Callback function invoked when the
 *   user clicks the 'Cancel' button, typically navigating away or closing
 *   the form.
 * @param {Function} props.completedHandler - Callback function invoked after
 *   a successful registration attempt, typically navigating the user to a new
 *   view or closing the form.
 * @returns {JSX.Element} The rendered sign-up form component.
 * @example
 * const handleCancel = () => console.log('Signup cancelled');
 * const handleComplete = () => console.log('Signup complete');
 * // In a parent component's render method:
 * <SignUp
 *   cancelHandler={handleCancel}
 *   completedHandler={handleComplete}
 * />
 */
const SignUp = ({ cancelHandler, completedHandler }) => {
  /**
   * Tracks whether the registration form is currently being submitted.
   * Used to disable the submit button and provide visual feedback.
   *
   * Tracks the value and setter for submission state.
   * // { value: boolean, setValue: Function }
   * @type {object}
   */
  const [isSubmitted, setIsSubmitted] = useState(false);

  // Stores an array of user-friendly error messages generated by
  // `translateError` from registration attempt failures.
  const [errors, setErrors] = useState([]); // {Array<string>}

  const { register } = useUser();

  // Refs for input elements
  const usernameRef = useRef(null);
  const emailRef = useRef(null);
  const passwordRef = useRef(null);
  const confirmPasswordRef = useRef(null);

  // Ref to track the name of the currently focused input
  // const focusedInputRef = useRef(null);

  // Holds the current values entered into the registration form fields
  // (username, email, password, confirmPassword).
  // {object}
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
  });

  /**
   * Handles the form submission event.
   *
   * Prevents default form action, sets submission status, clears previous
   * errors, calls the `register` function from `UserProvider`, and handles
   * success or error outcomes. On success, calls `completedHandler`. On error,
   * logs the error, translates it for the user via `translateError`, updates
   * the `errors` state, and resets submission status.
   *
   * @async
   * @param {Event} e - The form submission event object.
   * @returns {Promise<void>} A promise that resolves when the submission process
   *   (including potential error handling) is complete.
   */
  // Handles the form submission event.
  const handleSubmit = async e => {
    e.preventDefault();
    setIsSubmitted(true);
    setErrors([]);
    try {
      await register({
        username: formData.username,
        password: formData.password,
        email: formData.email,
      });

      if (completedHandler) completedHandler();
    } catch (e) {
      const timestamp = new Date().toISOString();
      handleError(e, {
        context: 'SignUp.handleSubmit',
        payload: { username: formData.username, email: formData.email },
        // Don't log passwords
        onError: (handledError, context) => {
          console.error(
            `[${timestamp}] [ERROR] [SignUp]: ` +
            `Registration error for ${formData.username}:`,
            context.message || handledError.message
          );
          // Use translateError for user messages
          setErrors(translateError(handledError));
        },
      });
      setIsSubmitted(false);
    }
  };

  // Attempt to fix reszing focus bug
  // Effect to restore focus if lost after state update (e.g., typing)
  // useEffect(() => {
  //   const inputNameToFocus = focusedInputRef.current;
  //   if (inputNameToFocus) {
  //     let elementToFocus = null;
  //     switch (inputNameToFocus) {
  //       case 'username': elementToFocus = usernameRef.current; break;
  //       case 'email': elementToFocus = emailRef.current; break;
  //       case 'password': elementToFocus = passwordRef.current; break;
  //       case 'confirmPassword': elementToFocus = confirmPasswordRef.current; 
  //       break;
  //       default: break;
  //     }
  //
  //     // If we found the element and it's not currently focused
  //     if (elementToFocus && document.activeElement !== elementToFocus) {
  //       // Optional: Preserve cursor position
  //       const currentPosition = elementToFocus.selectionStart;
  //       elementToFocus.focus();
  //       // Try to restore cursor position (might need adjustment)
  //       try {
  //         elementToFocus.setSelectionRange(currentPosition, currentPosition);
  //       } catch {
  //         // Handle potential errors if element type doesn't support 
  //         // selectionRange
  //         console.debug(
  //           `[${new Date().toISOString()}] [DEBUG] ` + 
  //           `[SignUp effect]: Could not set selection range.`
  //         );
  //       }
  //     }
  //   }
  // }, [formData]); // Rerun when form data changes (i.e., during typing)

  return (
    <Row className="justify-content-center" style={{ width: '100%' }}>
      <Col md="8">
        <Card className="my-4 bg-secondary text-white bg-opacity-25">
          <CardBody>
            <div className="divider-container">
              <div className="divider-line" />
              <span className="divider-text">
                <h3>Sign Up</h3>
              </span>
              <div className="divider-line" />
            </div>
            <Form onSubmit={handleSubmit}>
              <FormGroup>
                <Label for="username">Username</Label>
                <Input
                  id="username"
                  name="username"
                  type="text"
                  value={formData.username}
                  onChange={(e) =>
                    setFormData({ ...formData, username: e.target.value })
                  }
                  required
                  autoComplete="username"
                  innerRef={usernameRef}
                // onFocus={(e) => focusedInputRef.current = e.target.name}
                // onBlur={() => focusedInputRef.current = null}
                />
              </FormGroup>

              <FormGroup>
                <Label for="email">Email</Label>
                <Input
                  id="email"
                  name="email"
                  type="email"
                  value={formData.email}
                  onChange={(e) =>
                    setFormData({ ...formData, email: e.target.value })
                  }
                  required
                  autoComplete="email"
                  innerRef={emailRef}
                // onFocus={(e) => focusedInputRef.current = e.target.name}
                // onBlur={() => focusedInputRef.current = null}
                />
              </FormGroup>

              <FormGroup>
                <Label for="password">Password</Label>
                <Input
                  id="password"
                  name="password"
                  type="password"
                  value={formData.password}
                  onChange={(e) =>
                    setFormData({ ...formData, password: e.target.value })
                  }
                  required
                  autoComplete="new-password"
                  innerRef={passwordRef}
                // onFocus={(e) => focusedInputRef.current = e.target.name}
                // onBlur={() => focusedInputRef.current = null}
                />
              </FormGroup>

              <FormGroup>
                <Label for="confirmPassword">Confirm Password</Label>
                <Input
                  id="confirmPassword"
                  name="confirmPassword"
                  type="password"
                  value={formData.confirmPassword}
                  onChange={(e) =>
                    setFormData({
                      ...formData,
                      confirmPassword: e.target.value,
                    })
                  }
                  required
                  autoComplete="new-password"
                  innerRef={confirmPasswordRef}
                // onFocus={(e) => focusedInputRef.current = e.target.name}
                // onBlur={() => focusedInputRef.current = null}
                />
                {formData.password &&
                  formData.confirmPassword &&
                  formData.password !== formData.confirmPassword && (
                    <div className="text-danger small mt-1">
                      Passwords must match
                    </div>
                  )}
              </FormGroup>

              {/* Display errors */}
              {errors.length > 0 && (
                <div className="alert alert-danger mt-3">
                  <ul>
                    {errors.map((error) => (
                      <li key={uuidv4()}>{error}</li>
                    ))}
                  </ul>
                </div>
              )}

              <div className="d-flex justify-content-between mt-3">
                <Button type="button" color="danger" onClick={cancelHandler}>
                  Cancel
                </Button>
                <Button type="submit" color="primary" disabled={isSubmitted}>
                  {isSubmitted ? 'Signing Up...' : 'Sign Up'}
                </Button>
              </div>
            </Form>
          </CardBody>
        </Card>
      </Col>
    </Row>
  );
};

SignUp.propTypes = {
  /**
   * Callback function invoked when the user clicks the 'Cancel' button.
   * Used to signal the intent to abandon the signup process.
   *
   * @type {Function}
   */
  cancelHandler: PropTypes.func.isRequired,
  /**
   * Callback function invoked after the registration attempt succeeds.
   * Used to signal completion, e.g., for navigation or state update.
   *
   * @type {Function}
   */
  completedHandler: PropTypes.func.isRequired,
};

// Wrap the export with React.memo
const MemoizedSignUp = memo(SignUp);

export default MemoizedSignUp; // Export the memoized version
