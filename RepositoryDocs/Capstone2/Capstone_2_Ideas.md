# Capstone 2 Ideas

---


### 1. Code Squall: Code Problems Website

**Code Squall** is an app designed to provide a platform for coders to enhance their learning journey. Coders may face difficulty in solving a problem due to limited resources or from challenges.  It can encourage learning by curating a list of problems that they can solve, and by searching through categorized questions.

Questions can be properly designated and allow searching based on filter settings. Coding problems could have a different submission style, such as by implementing fixes to a previously accepted submission in the first step of a question, or by launching into a codebase with pre-written code, leading to a more active environment for learning. Some coding questions may incorporate time limits in each part of the code to simulate time requirements in difficult conditions.

Tests for problems will be tested in a sandboxed environment with less constrained servers, reducing testing times and testing time predictability. As a future milestone, time or space complexity of a test submission can allow parsing through Static Analysis, determining the result of a submission.

Submissions can be tracked, with each submission and its result or output to help assist debugging. You can share submissions and receive feedback.

A user's profile page can be tracked through amount of submissions, or problems solved, along with other preferences such as preferred coding languages / speaking languages.

Coding problems can be generated by implementing AI tools to reduce the workload on the community aspect of many popular websites.

### Comparison of other Leading Related Sites

**Codecademy** incorporates several features to encourage continuous learning:
- A point system rewards learners for completing exercises and achieving milestones.
- This gamification element can increase engagement and motivation.
- Progress tracking allows learners to visualize their journey through the curriculum.

**HackerRank** uses a combination of automated testing and peer review for many challenges. This dual approach helps ensure solutions are not only correct but also well-written and efficient.
  
**LeetCode** offers a straightforward, utilitarian interface focused on presenting problems and allowing quick submission of solutions. While functional, it may lack visual appeal for some users.  
  
**Codewars** boasts an impressive user interface that enhances the overall user experience.  
Its martial arts theme and gamified elements can make the learning process more engaging and fun.

**Code Squall**

- Utilizes free-tiered LLM API's to run a series of prompts and reduce community strain.
- Categorize the complete scope of the type of problem depending on the severity
- Enhance the question, allowing multi-part questions by LLM's.
- Allow rating the ‘difficulty’ of a problem
- Provide a ‘tiered’ or 'curated' learning system based on difficulty, with a rotating daily problem.
- Parse and determine translations to other languages, making the website self-sufficient.
- Improve the quality and quantity of hints that are necessary for solving the problem.
- Accrue and cite other educational resources that may be helpful, furthering the development before and after the problem has been solved. 
**Social**
 - Ability to share problems and update meta-data for effective link sharing.
 - Reviews section to allow users to comment on the code, accepting markdown input.
 - Allow a 'sandbox' environment to test out code and functions. (Similar to ipython or a node shell instance.)

A single free-tier LLM can be utilized for specially crafted prompts:
https://github.com/cheahjs/free-llm-api-resources

**Challenges**

- Setting up run-times to test code submissions in sandbox-ed environments requires an easy-to-scale distributed server setup using Docker.  
    Docker to run sandboxed environments and scale capacity for processing for test submissions and test cases. At minimum it will have Python/JavaScript with most recent versions as first sandbox environments. A background process will determine when to scale up new instances.
      
    With these schedulers in-place, each individual environment instances can be deployed to dedicated resources waiting for work, applying quick and easy adjustments to spawn new processes or decrease available instances in production to handle 'simulated test loads' or 'scaling'.
    
**Other Concerns**

- Restricts the potential users (i.e. Non-Software Engineers)
- Translations to other languages for specific code problems may be completely off
- Links found may be completely outdated due the sourcing dates by earlier gen. LLM's, while retrieval of links may require adding implementation of a premium LLM on a free-tier request structure.

**Front-End** 
	React, JavaScript
**Back-End** 
	Express, PostgreSQL. MongoDB, Python for Back-End/Docker Scheduling and spawning
	
Other Tools - Redux, Docker, Free LLM's, free-tier Premium LLM's (Anthropic, OpenAI)


---
# 2. Citadel Command

Web-based browser game built in React. A Tower Defense game. It's a basic tower defense game with additional logic for efficient pathfinding by enemy AI. 
### Key Features

1. Multiplayer capabilities
2. Mobile-first design with cross-device compatibility
3. Dynamic maps with limited movement during gameplay
4. Manual turret aiming for attacking opponents
5. Multiple valid paths for enemies
6. AI destruction of structures (with toggle option)
7. Detailed enemy information display (% HP, armor levels)
8. Multiple view modes (FPS and bird's-eye view)
9. Boss battles
10. Save-game feature
11. Single Sign-On (SSO) for account management
12. Varied enemy types across different game stages
13. Research and tech progression system
14. Tutorial system for new players
15. User profiles for saving progress
### Gameplay Mechanics

1. Tower defense core gameplay
2. Store and upgrade system
3. Aim for 3 hours of unique gameplay per playthrough
4. Adaptive difficulty requiring strategy changes throughout the game
5. Real-time changes between stages and levels

### Technical Challenges

1. Balancing game formulas for an engaging player experience
2. Implementing dynamic 3D environments
3. Managing complex state changes in React
4. Handling real-time multiplayer interactions
5. Optimizing performance for mobile devices
6. Implementing AI for enemy pathfinding and structure destruction
7. Creating seamless transitions between different view modes
8. Developing a robust research and tech progression system

---

To make the project fit within the allotted timeframe, the most important basics will be set up per day, with more complex features at the end.

1. Basic Tower Defense System
	1. Place towers
	2. Basic enemy spawns
	3. Tower Types and attack range, health system
	4. Win or Loss conditions
2. Currency and Scoring System
	1. Receive points for defeating an enemy
	2. Points for completing a level
3. 3D Environment, skybox and 3D scenes
	1. Basic terrain and dynamic maps
4. Enemy Types
	1. 2-3 basic enemy types
	2. Pathfinding
5. Basic UI
	1. React-based, states, form control, and components
	2. Tower Selection interface, Tutorial, guide
 6. Tower Upgrades
	 1. Progression for improved towers, wave time upgrade, level progression
7. Map dynamics: moving pathways, dynamic level changes
8. Save System
	1. Save current level
	2. Save current character
9. Basic Tutorial
Technologies (Summary)
React with Three.JS 3D Rendering
PostgreSQL, MongoDB, sockets.io

---
# 3. Farming Simulator

New users can plant crops with varying degrees of difficulty. To play the game, players can learn the basics of growing crops and then increase their skills, improving the ability to grow more expensive crops or crops that require unlockable skillsets. Progression in the game opens up additional features of the game such as accessibility to tools and other unique harvesting methods.

1. **Farm Plot System**
    - Create a grid-based farm layout
    - Implement basic crop planting and harvesting mechanics
    - Include 2-3 crop types (e.g., wheat, carrots, potatoes)

2. **Crop Growth Cycle**
    - Implement a simple growth timer for crops
    - Visualize different growth stages (seed, sprout, mature)

3. **Weather System**
    - Create a basic weather cycle (day/night, rain/sun)
    - Implement simple weather effects on crop growth

4. **Basic Economy**
    - Introduce a currency system
    - Implement buying seeds and selling harvested crops

### User Interface

5. **Farm Overview**
    - Create a top-down view of the farm
    - Implement basic UI for selecting and interacting with plots

6. **Inventory System**
    - Design a simple inventory for storing seeds and harvested crops
    - Implement basic crafting for turning raw crops into products

### Additional Features

7. **Basic Tools**
    - Implement 2-3 basic tools (e.g., watering can, hoe, sickle)
    - Create simple tool usage mechanics

8. **Simple Animal Husbandry**
    - Introduce one animal type (e.g., chickens)
    - Implement basic feeding and egg collection mechanics

### Technical Implementation

1. Set up React project with a suitable 2D rendering library (e.g., Pixi.js)
2. Implement basic state management using React hooks
3. Use local storage for saving game state (to avoid backend complexities)
4. Set up an efficient way for 'fast-forward' for players who prefer a real-time experience.

### Sprint Ideals

1. Simplified visuals: Use sprite-based graphics for quick implementation.
3. Placeholder assets: Use temporary art assets to be replaced later.
4. Modular design: Structure code to easily add new crops, animals, or tools later.

### Potential Challenges

1. Balancing gameplay: Ensuring the game feels rewarding despite simplifications.
2. Performance optimization: Managing multiple growing crops efficiently.

---

Thank you for reading!